om shree ganeshaya namah
om shree sita rama lakshman hanuman

om shree ganeshaya namah
om shree sita rama lakshman hanuman

- Java completed 25th birthday in 2020 and still java is very very rock solid, reliable and stable
- Even Code written in jdk 1 can be executed using jdk 17 without recompiling
  eg: take .class compiled using jdk1 and run using jdk 17 it still works same with jar
      created jar using jdk1 but running java -jar using jdk 17
  This is one of the main reason for java's enterprise/production success
  Version of java can be upgraded/downgraded without much hassle : backward and forward compatibility

- During Relase of jdk8's era new version used to come after years like 2-3 years and even more
  but now a new release cycle is used of 6 months now

- Java new Version evolution happens to add new features as well as enhance performance, space,security and ease of usage

- Earlier java had feature driven release cycle causing huge time for next version release
  but after release of jdk 10 release cycle is based on time
  ths will ensure no postponing of releases like jdk 10 due to huge feature modules
  eg 3 features were planned but 2 were complete and hence these 2 will release and 3rd feature can wait for next cycle
  adds rapid inovation + no postponing of release
- now we have 2 releases per year : march and september
- now the versioning of each jdk version contains release date along with jdk release version 

- each release can be long term supported or non long term supported
  plan is to have LTS release after every 3 years
  LTS means java will support this enterprise version until a new LTS is launched
  so we can have version migratio every 3 yearsor n years which is planned for next LTS release

- Starting from jdk 11 Oracle JDK is paid to be used in production but free for local development and playground  
- Oracle also provides openjdk which is free even in production
  there is another open source community version aka adoptopenjdk this is also free in production
  other providers are amazon correto, azul zulu, ibm, redhat,sap etc
- after jdk 17 release in septmeber 2021 LTS support release cycle is moved to 2 years instead of 3 years
  also there is  new licence introduced using which we can use versions >=jdk 17  free even in production
  but subject to conditions mentioned in the license. Open jdk remain free with 6 months support as usual

=============== JDK 9 Features================  
- Java provides garbage collectors for automatic memory management so that developer need not do it
- G1 is default Garbage collector in jdk 9 before that it was CMS
  using G1 garbage collector we can configure customized pause time
- G1 G.C seggregate the heap into multiple regions based on size of heap and number of regions
  it identifies each of these regios as eden, survivor and old
  it calculates the density of these regions  
  
- Reason of compact strings
  In Java strings are stored in form of char[]
  each charachter[] index stores 2 thing one is characther type(unicode like if it is utf-8 or utf-16) 
  and other actual charachter  hence size of each charachter is 2 byte
  Important observations were made by jdk team using multiple heap dumps of projects
  a. Strings in project mostly uses non special charachters so why need unicode type 
  b. around 30 percent of the heap memory used is char[] from strings
  
  if we can compact string char[] : each char to be 1 byte by remocing the ubnicode type header
  we can save huge amount of space as 30 % of total heap is char[] from string
  This feature is known as compact string : introduced in jdk9
  Using this java uses byte[] to store string instead of char[] hence saving huge memory and have better performance
  Even Stringbuilder and Stringbuffer uses compact strings
  
- Benefits of compact string
  a. memory footprint reduction in string and strinbuilder/buffer classes hence huge heap memory is saved
  b. less freequent G.C as less memory is used
  c. better performance as byte operations is faster than char operations
  d. Also notice these changes do not require any change from dev perspective
    everything is happening under the background  
	
- Benefits of indify string concatination feature
  if we are using str1 + str2 +str3 in single line in jdk 8 it uses append method of Stringbuilder
  at compile time this feature is done
  but this direct append is not always good as strinbuilder/buffer have fixed size and it grows based on usage
  as str2 size can be different it grows during run time and it should be made better
  also we need to ensure that any new implementation/algo is done at runtime so that we need not to recompile
  meaning same compliled code in jdk 9 can be made better in jdk 11 or so
  hence it uses combination of invokedynamic and method handles
  This feature ensures that stringbuilder size is fixed (calculated by adding size of all strings at compile time)
  hence no need to grow stringbuilder during append as it is fully capable to store all strings
  
om shree ganeshaya namah
om shree sita rama lakshman hanuman

Why we need modularity
a. Typically in a java alicacation we create class and then package as jar
one project output is jar as well as it needs to access code present in another jar
we need to add all the jar in the classpath while running the java app using java command
if we miss out a jar that will fail only at runtime when that class using code is called: fail very late
 -> NoClassDefFoundError
 AKA jar hell
b. Weak encapsulation: Every public class is visible to other classes even outside jar
  We can not hide or show a class , if that is needed within jar is fine but not outside the jar
c. very big monolithic rt.jar: IT contains all the code/bootstrap for internal java API library
  It was very big and contained everything but not everything was needed in all projects
 
JPMS addresses above issues

- A Module is nothig but collection of packages (package containing code of classes/interfaces and data) 

- Remember JPMS is forward and backward compatible
  if we have a jar/java project we can add tha using module path or classpath both works
  but for module path we need module-info.java class and need to remove this for classpath
  using modulepath way we will get strict encapsulation and security
  the classpath approach is also known as unnamed module
  the module will be null for this
- Features of unnamed modules
  a. It can be used by adding in classpath and not in module path
  b. no name is there and class is unnamed module
  c. Can be used without module-info.java
  d. It is not secure as all the public classes/interfaces will be visible fully by the user project
  e. It can openly use code of user module as well as any jdk module fully with no encapsulation
  
The above features are very important as we can move classpath dependencies gradually step by step to modular path
  
- Automatic Module means when we are not having module-info.java and using java argument with module pathduring runtime
  it automatically creates a module and that can be used
  this is only when module-info.java is not added to project then project name becomes name of automatic module
  while running main class we can give this module path(automatic name)
  
- Features of automatic module
  automatic module can access code from all other modules
  every package in automatic module is exported
  IT can be helpful in migration
  Whenever we create a project/jar with no module-info class it creates automatic module
  this can be use din client project by adding to module path
  follow the rules on the nomenclature of how name is defined for such automatic module
  
om shree ganeshaya namah
om shree sita rama lakshman hanuman

- Usage and Features of different modules with scenarios
a. named module: When we have module-info.java for a project
   all the security/encapsulation features exist on this in usage as well as exposing
   remember a named module can not use a jar/project with no modules in classpath
   only if in the user project module-info does not exist a jar/project can be used in classpath
b. unnamed module: when we have a project with no module-info 
    it can use another project with no module-info class by putting in classpath
	the imported project is added to unknown module
	All client code can use this and this can use jdk aad client code fully with no modular encapsulation
c. automatic module: in case client project is already having module-info class
   we can not add non modular project in classpath we need to add that in module path
   the name of project/jar is used to derive name of this automatic module
   client need to add requires in module-info and this can be used with no boundaries just like unnamed module
   this is used while migration as few jar/project might not be modular and few will be
   
- Since internal JDK APIs are encapsulated using modules a lot of internal libraries are hidden
  they can not be used even thought we try requiring modules,
  eg sun package which were suggested by java not to use since jdk8   
  code for sun.* package ued to give warning in compilation and running in jdk 8
  but now since jdk APIs are encapsulated using modules
  these are not exported and hence wont compile and run using version > jdk9  
  -> We can solve this issue by taking help of jdeps tool which tells what all module dependency is there for a project
   it tells all the warning and providews suggestions like which class can not be used other than sun.* package etc  
 
- Jlink or Jlinker is a command line utility present in jdk home/gin directory where java is installed
  Using this we can create custom JRE based on specific module we need and ignore which is not needed
  compact JRE = better space utilization + fast startup + faster class loader + Better JVM G.CMS
- Steps: Create Code and modules -> Compile -> Create Custom JRE based on modules -> run using custom JRE  

om shree ganeshaya namah
om shree sita rama lakshman hanuman

=============== JDK 10 Features================
a. Method Local Variable Type Inference: Write Clean and Clear reading code
b. Optional orElseThrow method
c. Collections new unmodifiable map API
d. Application Class Data Sharing:
   Helps in reducing JVM startup time, reduce memory footprint
   -> It shares the classes metadata across multiple JVM instances
e. improved docker container awareness: bugfix in JVM

- Meaning of Type Inference : Compiler should be able to infer/judge data type
  evolution of type inference in java
  JDK7: introduction of type inference in generics: compiler can infer type from left side
  JDK8: in lambda the type of input to lambda expression can be inferred form left hand side variable declaration type	
  JDK10: method local variable type can be inferred from the initialized value from the right hand side
- Remember introduction of local variable type inference does not make java a dynamically typed language
  It is still statically type as compiler infer type from right and insert the same in the byte code instruction
  
Type inference can not be used in
a. Class level field type
b. Method return Types
c. Method Parameter Type
d. Constructor Parameter
e. catch block variable declaration

- Remember that var is not reserved keyword so we can have a variable with name var
  , Also note that we can not have seperate declaration and initialization lines of code
   we must initialize and declare in same line of code  
   
- If we use var in declaration then all the variable names are inline to same column
  making sure of more readability   
  		//below is bad because of performance
//		byte count = 1; // stored in byte will be space efficient 
		var count=1; //int takes more space
- Good Case is to use var when the data type name is very big and it is guranteed to be of right hand side
  do not use this if code readability is reduced or it is not giving advantage in code readability		
  Also note var inference is best used when variable name is chosen properly
  Be Careful while using var for generic collections , better to use strict types here
  as while using var it takes it as object defeating the purpose of generics compile time type safety
  
- Java architechts are planning to deprecate get method in optional
  IT is because if item is null get method throws exception
  a lot of developers misued it thinking no exception will come but null object can be receieved
  this was a mistake admitted by java architecht to have get method throw exception
  so in future it will be deprecated and we can use orElseThrow method which is same as get
  but method name is more sensible and clean  

- We have below features in collections
a. copy constructor: we can pass any collection and get any collection
  however both will be deep copy, adding/modifying/removing in one wont reflect in other
  but the copy collection will be modifiable
b. Collections.unmodifiable
   Takes collection and create read only view of that collection
  from read view can not add/delete/set or modify
  but on the main collection we can add/delete/set and that reflects on the read view
c. List/Set/Map copyOf static factory method copyOf takes collection as input return unmodifiable collection
   from read view can not add/delete/set or modify
   but from main collection we can modify but wont reflect on read view   
   
- Application class data sharing 
  This feature is not very common but very useful if we need to have reduced startup time of applications ruinning on JVM
  CDS or class data sharing was introduced in jdk5 
  -> where bootstrap oob jdk classes once loaded is kept on cache, in case another jvm instance starts up in same machine
    -> that jvm machine can use these already loaded classes and hence reduces startup time
  Application class data sharing allows CDS to cache even application code
   like 3rd party libraries, our application code, imported module code etc
  so when a new JVM instance is loaded in same host these many classes metadata is shared and hence
   -> reduces memory footprint
   -> reduces startup time
  Specialy useful in cloud orchestrator like k8s where multiple pods of same app might be running in same node machine   
  meaning it saves startup time for multiple app running on sampe machine + if there is a restart then restart startup time will be faster
  Remember the class instances(java.lang.class) represented as class meta data is stored in meta space of jvm
  So the applicatin class data sharing means sharing of this metaspace area among multiple instance of JVM in the same host machine

- Note Class Data Sharing was there since jdk 1.5
- Steps to enable Class data sharing pass below flag whilerunning java command
  Step a. java -Xshare:dump
  by default it select a file JAVA_HOME/lib/classlist  where all names of classes are given for which CDS must share cache
  for these bootstrap classes(code jdk classes) only metaspace info will be cached and shared
  the output of above step will be: JAVA_HOME/bin/server/classes.jsa
  step b. java -Xshare:on -Xlog:class+load MainClassName
  
- Steps to enable Application Class data sharing pass below flag whilerunning java command
  Step a. java -Xshare:off -XX:+UseAppCDS -XX:DumpLoadedClassList=app.lst -cp app.jar MainClassName
  This step loads all the application+imported modules/library into the dump file app.lst
  Step b. java -Xshare:dump -XX:+UseAppCDS -XX:SharedClassList=app.lst XX:SharedArchiveFile=app.jsa -cp app.jar MainClassName
  This step dumps all the bootstrap classes + step 1 dump files's metatdata to shared metaspace cache
  Step c. java -Xshare:on -XX:+UseAppCDS -XX:SharedArchiveFile=app.jsa -cp app.jar MainClassName
  This starts the app + uses app and boptstrap loaded class metadata from the cache
  
om shree ganeshaya namah
om shree sita rama lakshman hanuman

- Before JDK 10 Java JVM was not aware that it is running on docker and hence no specialization
  So what used to happen is that if docker container is given a specific max memory jvm used to ignore it
  jvm was directly checking host machine for the memory and hence it was overflowing and causing docker container restart
  from jdk 10 JVM if running in docker (java flag is true by default) takes memory consideration from docker container allocated memory only

=============== JDK 11 Features================  
a. Http Client API : implements HTTP2 for websocket, async and non blocking request and response
b. local variable synax for lambda parameters: use of var extension in lambda expressions
c. String API changes: repeat, isBlank, strip and lines methods
d. Deprecations and Removals: Remember during migrations we must know if old library is deprecated or removed
    This helps in migration planning
e. Single File Source code program : write code like scripts and run directly without compiling
f. Garbage Collectors: Epsilon and ZGC collectors
g. New APIs for Files and Predicate to write cleaner code
h. Flight Recorder: Using JMC

New HTTP Client API
Why
a. The Existing HTTPURLConnection API is very low level, verbose, non declarative and need lot of boilerplate code
b. poor mainainance
c. supports blocking http1 only

Earlier we were using external libraries like okhttp, apache http client, spring resttemplate and Webclient etc
java Http Client API replaces HTTPURLConnection API 
 -> Pretty high level
 -> Fluent Builder pattern
 -> Less Verbose and hence more maintainable
 -> Support Websockets, HTTP2(default support) sync and async request and response, also supports HTTP1
    Also integrates well with reactive programming patterns implemented using Flow API in jdk9
 -> incubated in jdk9 but is live in jdk 11	
 
- String class added repeat method : meaning same string will be concatenated with existing string n-1 time
   eg: "#".repeat(2) will result ##
    "".repeat(6) return empty string and "#".repeat(0) returns empty string
  Question is why we need this method if we can do this using for loop
  It is because it uses byte[] which is more performant and have better space utilization  
  
- We can not use isEmpty for blank check as it checks length == 0 which will be tru for actual empty string
  so we need to use trim method and if that is empty than actually the item is blank
  however since jdk 11 we can use this directly from String class and have better performance
  Trim method remove all the spaces from beginning and ending
  remove all spaces from initial to first charachter and then remove spaces starting  from last to end  
  
- trim vs strip 
  trim method has been since beginning and it removes all the starting and ending spaces
  however it do not consider different charachters like /n /t as spaces and those are retained if used
  if strip is used it considers these special charachters like /n /t also as to be removable from starting and ending
  
om shree ganeshaya namah
om shree sita rama lakshman hanuman

- Epsilon Garbage Collector is a no op grabage collector 
  that actually do not collect garbage and clean unused object to clean up free memory
  so eventually more and more object will take space and unused once will not be freed for memory
  hence JVM will shut down once all space is exhaushted
  Can be used in case of performance testing : in case of memory constraint environments we can set max heap memory 
  and then in this test environment we can analyze load test
- Use cases of epsilon Garbage collector
  a. Performance test environment : sometimes G.C pauses can actually give wrong info on the actual software's performance  
  b. Extremely short lived but high performant applications: To enhance performance we can completely stop G.C
     since application is very short lived very few objects will be created hence we can stop G.C
  c. Extremly high performant applications	 
  
		byte[] bytes = new byte[1024];
		
		for(int i = 0 ; i < Integer.MAX_VALUE ; i++) {
			//after every iteration the byte array object is free for g.c
			//if epsilon gc is enabled it wont free up and will have eventual out of memory error
			bytes = new byte[1023];
		}
		
		System.out.println("Task Completed final bytes: "+bytes);

- ZGC is a scalable , low latency garbage collector
  -> concurrent G.C meaning app thread and memory deallocation G.C threads are different and run in parrallel	
  Remember G.C causes pause but this is very efficient max pause time is 10 ms
  even for higher heap size the pause time is fixed to be max 10 ms
  Can handle huge size of heap sometimes even in TeraBytes
  
- Since JDK 11 multiple enterprise level modules are removed 
  eg: jaxb(xml object mapper) , jax-ws(soap based web services) , corba, JTA
  these modules were removed as these were moved to maven artificatories and were enhanced already to huge level
  so user whoe is using on enterprise level can use maven.gradle or other artificatories
  hence removed from java internal modules  
  
- Starting from jdk11 the javafx module is removed and is moved out to external provider
  we can either use their jar or use maven/gradle artifactory and that project is open sourced
  the open sourced project is known as openjfx
- Java Applet are completely removed since jdk 11 due to dangerous security issues
  we can use html css and js to replace such applications  
	
- JDK 11 introduced single source file execution
  we can write multiple classes in single source file and can run without even compiling: good convenience
  Since no need of compilation it do not generate .class file
  This is supported only for single source file classes only
  
- SheBang is very famous in shell script creation in unix os
  #! means sharp(#) + bang = shebang
  in any typcial script file we start the first line as
  #! /bin/bash or in general #! programming language interpreter path eg" #! /usr/bin/python
  We know that scripts using bash or python are very famousto write automation steps in unix OS or any OS
  Hence combination of single source file compile less execution and shebang we canwrite automation script in java
  meaning we can write automation code that can be ececuted as script eg : /dir/filename.sh

- Steps to create a script based java code
  a. start the file with #! then path to java installation
  b. create a class with a main method and write any code needed there for automation script
  c. save the fle with same class name but no extension
  Make a note that shebang are scripts that gets executed in linux machines and not windows  
  using bash in windows we can do the same
  
om shree ganeshaya namah
om shree sita rama lakshman hanuman

- Files class is added with new method readString
  earlier we could read all lines of file in single string object using new String(Files.readAllBytes());
  but it is low level we can use readString method to fetch all lines in single string
  lines and readLines are existing method to get Stream<String> and List<String>  etc
  each entry representing single line only
  Also make note that readString and readLines are eager so all file lines will be read and loaded to memory
    hence these 2 method can cause out of memory error in case the file is very big
	Stream is lazy and hence it fetches one by one and hence less chance of out of memory error
  
  Similarly Files is added with writeString method : it writes whole string to file in one go
  
- JFR or java Flight recorder is a profiler tool that generated jvm based metrics in .jsr file
  to graphically view this and have meaningful analysis in chart form we can use JMC : java mission control
  it can work directly with jvm but internally will still use JFR
  
om shree ganeshaya namah
om shree sita rama lakshman hanuman

=============== JDK 12 Features================    

a. CompactNumberFormat: Before JDK12 we had number/currency/date formatting/parsing features but not in compact way
   one example is twitter/instagram showing number of followers like 10.2 M, 11.6M 
   i.e in short/compact form + Locale specific based on country
   like in usa 1k works in usa 100 M etc, in germany same is represented as 1.000,100 Mio respectively
   Representing numbers in compact form increases the readability and hence can sell products to more customers   
   
b. Files new method mismatch to compare equality of 2 files
 use mismatch method of Files class returns -1 if content byte arrays of files are same
 or else return the index at which the first charachter is different
c. JMH micro benchmarking
d. Shenandoah Garbage Collector
   It reduces the pause time to minimal by having concurrent sweep and compaction tasks
   developed by redhat, useful for high responsive applications with less g.c pause time

e. Teeing collector in Streams API
   Make a note that linux os have teeing features
   where single input soruce can be added to console as well as multiple files
   single input data can be processed to multiple operations giving result to multiple outputs to difference output sources
   Based on the same linux teeing concepts a new stream collector is added in jdk12
   Same stream of data input can be manipulated by 2 collectors and then these results of individual collectors can be merged
   basically merged 2 collectors results
   

f. Preview Features
  Introduced in jdk12 , it means concept is fully implemented and designed and specified
  however implementation is not final and may change
  useful in case of gathering feedbacks from dev
  release a new feature as a preview , disable by default we can enable it manually
  java architechts gather feedback from dev and then finally publish in future release
  a preview feautre might be finalized in future release of might be completely removed in future, hence these features are disabled by default
  
  one such example is switch expression which was preview in 12 and 13 and in version 14 it was finalized
  in new switch feature we can use lambda expression: it adds code readability and no need of manual break statement
  
g. String added indent method to indent each line by the passed same space to method
   String added transform method tat taks a lambda function of Function interface
   This adds readablity and laziness and reusability of the code: like a fluent builder pattern   
   
- Benchmarking is a technique to analye performance of software with different loads
  so we can use specific algo based on load needs
- Microbenchmarking means benchmarking to very minute level like analysing a method
 or read/write specific query in specific d.b/cache  
- Java provides JMH java Microbenchmarking Harness a tool that can do Microbenchmarking within jvm for multiple methods
  Before JDK12 this was used as seperate external library imported using maven/gradle/jar
  but since JDK12 it is added as part of jdk library

- Why we need JMH tool when we can write time difference in code for the mehod to benchmark
a. JVM must be warmed up so that JIT compilation happens at the same level for different methods to compare method execution time
b. JVM is smart enough to ignore certain hotspot code : eg a for loop that is not beeing used after the loop
   JVM understands this bottlenect and ignore to execute this
   but during method level code written approach it will execute and will get fake extra time in performance test
   
om shree ganeshaya namah
om shree sita rama lakshman hanuman

=============== JDK 13 Features================    
Features released:
a. Reimplemented New Socket API : Old socket API was released in jdk 1 
b. Dynamic CDS archives: In JDK 10 app CDS was implemented
   that feature is enahanced to dynamically pick the app classes to be cached
c. text blocks: add features to support multi line strings
    It makes ease of use and developer friendly for multi line strings
    also enhances code readablity for multi line strings
d. String API changes to support text blocks
e. switch expression change
f. ZGC enhancement

- The Socket API was completely rewritten for future goals
  We must understand why this was done and what it affects
 A socket is a way of communication b/w 2 machines
 Using Socket client library we an write code to create socket in client machine
 similarly we can use socket server library to create socket for exposing programs
 Legacy Socket API packages: java.net.Socket, java.net.ServerSocket
 Issues with legacy socket API
 a. Code was not maintainable: written in java and c and native methods making it tough to understand and maintain
    These native methods and native locks were not easy to understand and reuse and enhance causing maintainablity issues
 b. concurrency issues : was using synchronization blocks and method
   making it slow, poorly performed and other issues like fairness etc

API is Reimplemented using NIOSocketImpl
benefits
 a. uses nio libraries which is no blocking hence better performance for bulk operations
 b. object outside heap support good for bulk data transfer
 c. better code maintainablity
 d. uses Locks which are fair and better performed , also not all methods are synchronized
    making it better performant as individual locks are used based on use case
 e. Project Loom suppport: loom is one of the biggest development in openjdk,
     looms uses fibers in jvm which are lighter than threads
	 in traditional threads one thread correspond to one thread in os
	 but fibers are lighter and multiple fibers correspond to single thread in O.S
	 (sometimes 1000s fiber work on single OS thread)
	 
- Legacy Socket API is not removed using jvm flag we can still enable it

- Dynamic app CDS is good for ease of usage
  in jdk 10 there were 3 step process but in jdk 13 we have 2 step process with lesser flags
  we can use onexist jvm option that directly create jsa file on exit of the jar
  and then we can use this directly with lesser jvm arguments while running the jar
- Another advantage of dynamic app CDS is that it support oob class loaders as well as custom class loaders
  app cds in jdk 10 only support oob class loaders only  

- Text block is a preview feature in jdk 13
  since a preivew feature is for feedback and it can change,  removed or be permanent based on feedback
  not suggested to use in production
  eg:
  String address = "c23 Fix Apartment\n"+" Sachi Road\n" + "Delhi"
  remember we might forget new line char
  text block is represente with """ and \n comes on its own when a there is a new line in string
eg: """c23 Fix Apartment
     Sachi Road
	 Delhi""" will result to same
	 it increases readability and also is more developer frient in terms of ease of usage
	 good use case is
	 json, html where we need to use escape charachter for \"name\":\"kanishk\"
	 it is because formatting indent is based on how we define text block
- in jdk 15 text block is permanent feature

if a file exist with below content
\"jai shree ganesha\"

\"jai\tumamahesh\"
\"jai shree sitarama lakshman hanuman\"


\"hello\tworld\"
if we use File.lines it will not convert escape charachter to unicode
hence result will be exact same  like first line: "jai shree ganesha"
instead it will be \"jai shree ganesha\"
we can use translateEscapes method

- String class is added with formatted method which is same like static method but this is instance method
  also remember even text blocks work well with string format like use of %s
  
- In jdk12 switch expression is made preview feature and in jdk14 it is made permanent

- ZGC introduced in jdk 11 was very fast and have 10 ms or similar pause time
  but even after gc is done that space is not given back to O.S even in no use case
  it is always assigned to jvm for the fact maybe in future it can be useful
  but in jdk 13 unused and gced memory(RAM) can be assigned back to O.S to do other task
  
  
=============== JDK 14 Features================     
a. switch expression
   -> Switch Expression was added in jdk 12(review feature) and now in jdk 14 it is permanent and hence can be used in production
   in traditional switch case lets see example
   we have switch and cases where we are doing computation in each case and then assigning a value to a method variable
   in this case we will have cases calling methods and method variable is assigned a value
   a. We need to break manually or else fall through happens
   b. for same logic for different case we need to kee them togehter with break only at last case
    these 2 things caused issue with code readability
	for experienced developer it was fine but not so much for new developers
	
 Hence switch expression was introduced
  a. we can assign the switch expression directly to variable
     meaning in each case we need not to assign the variable
  b. uses lambda expression format
  c. no need of break as there is no fall through  
  d. multiple cases can be combined using comma
  e. lambda arrow is used instead of colon
  f. Also Remember switch expression always must have default expression or else compiler complains
  these features adds  a lot of readability
  g. Remember that we can not have -> and : both in the same switch case
 
- Yield was added in jdk13  in jdk 12 it was break; 
   
b. helpful NullPointerException
  -> NullPointerException is a RunTimeException and hence never be try catch
     instead we should do validations so that this never occurs : but that can add a lot of if conditions
	 adding this many if else condition can cause bad code readability
	 if this flag is enabled for helpful NullPointerException
	 it can actually tell which method or variable was actually null that caused null pointer exception
	 by default it is disabled
	 This is helpful in debugging and hunt down NullPointerException on production but have a very slight performance issue
c. Garbage collectors improvements
   G1 the default G.C is impreoved in terms of performance
   Concurrent mark and sweep G.C was earlier deprecated and now completely removed
   ZGC (less pause time 10 ms even in case of tera bytes of heap size) is now added for windows and machine
   earlier it was for linux only
d. Records
   This is preview feature and hence not suggested to use in production
   To use this we need to enable preview feature in eclipse/sts/intellij or java compiler argument
   As a Java developer we have written DTOs which are nothing but data carrier
   it has fields initialzed with constructor and setters are not there
   since these are data carriers it should be immutable and hence
   all fields should be final private , initialized in constructor and no setters but getter
   should have hashcode, equals and tostring : writing self for these boilerplate is not easy
   IDE can help but with more fields comming or fields getting removed writing and maintaining this is not easy
   so lombook came but using records we can handle immutability + DTO easily
   Goal of records is modelling data as data with no bolierplate code to bve written
   It reduced boilerplate code , adds declarativeness shows intention that this is data carrier class
   hence code readability is increased and verbosity is reduced   
e. Pattern Matching for instanceof
   Again a preivew feature in jdk14
   To use this we need to enable preview feature in eclipse/sts/intellij or java compiler argument 
   When we use instance of inside true if condtion we actually do downcast
  this is obvious and hence redundant code is written
  this redundant code can reduce code readability and during copy paste we might downcast to wrong type
  obvious reduces readability adds verbosity and chance of error is there in copy paste
  This is permanent feature in jdk 16
  Also used in future switch expression  
  
om shree ganeshaya namah
om shree sita rama lakshman hanuman

  =============== JDK 15 Features================  

a. Text Block Enhancement (introduced in jdk 12 as preview feature)
   -> Starting jdk 15 it is made permanent and hence can be used in production
   Text Blocks starts with triple quotes and end with same
   We can not add content of text block in same line as starting tripple quotes delimeter
   however content is allowed in last line  last line"""; //allowed in last line -> compiles fine
   if ending """ is next to the content then an extra line is added with empty chars
   Remember that the text blocks are also interned meaning usable in string literal pool cache
   It is bad choice to use text block for single line string, better use basic string literal for that
   
	//text block benefit is code readablity
	//as part of clean code one line should not exceed a limit of width
	//this allows dev to read more code without scrolling to right and hence adds code readability

	//but what if we need not to use text blocks but actually append in single line
	//introducing escape charachter in text block in jdk 15
	use / at end of each line of text block and it wont add \n on its own
	and all lines will be appended to single line
	other escape charachter allowed in text block is \s hence only 2 escape charachters are allowed
	'\' and '\s'
b. helpful NullPointerException enhancement  (introduced in jdk 14 as preview feature)
   now in jdk 15 it is a permanent feature
c. Records enahancement
   In JDK15 records can be method local aand in certain use cases it adds encapsulation
d. Sealed Classes and interfaces
  In Java we can use inheritance to resuse and have polymorphic behavior with substitutionability
  but sometimes we want to restrict class a to be extended by b,c and d only other classes should not be able to extended
  options
  a. make class final : but it will restrict to have 0 children thats not what we want
  b. private constructor + nested classes : makes sense but sometime code readability is bad
  c. package private: works well but what if we want other packages to also be able to extend
  Sealed class is best suited for above use case introduced in jdk 15
  It is still a preview feature
  Syntax
  a. In iterface or super class we need to add public sealed class/interface Name permits Child1,Child2{
  }
  b. The children classes must be final and only Child1,Child2 are allowed to implement/extend
    for others it gives compilation error on implement/extend
	one logic is the children class must be either final or non-sealed
	for final children another class can not extend it
	but for non-sealed children other classes can extend it
e. G.C Enhancement , deprecations and removals
  ZGC is now a permanent feature + several enhancement like increasing max heap size to 16 tb
   already in jdk14 was made to be used in windows and mac also
   Shenandoah G.C is also made permanent
   but G1 is still default G.C
   
=============== JDK 16 Features================

om shree ganeshaya namah
om shree sita rama lakshman hanuman

a. Records in debth with numeous examples to build confidence
   Previewed in jdk 14 and jdk 15 is not permanent in jdk 16
 
   Behind the Scene is similar to that of enum
   Compiler creates a final class with record name that extends java.lang.Record class
   add a single constructor with decription provided
   no arg constructor is not created
   private final fields with same name as that of descriptin is created
   initialization happens in constructor
   no setter but public getter methods with same name as that of field
   hashcode , equals and tostring methods are provided by compiler too
   in short record gets compiled into a final class that extends java.lang.Record class just like enum type
   Rules:
   -> No Arg Constructor wont be created
   -> Record can not extend another class as it is already extending Record class
   -> it can implement n interfaces just like enum we have last 2 rules
   -> Just like enum type, a Record can have constructors too, if no constructor is added a canonical constructor is added
      in canonical constructor the field declared will be parameter and it will be copied to private final field automatically
	  however we can overload and can create our own constructors, 
	  field declared will have to be initializedby us by calling canonical constructor created by compiler
   -> we caa override toString , hashcode, equals method auto created by compiler
   -> A Record can act as key of hashmap as compiler provides hashcode and equals methods automatically
      hence using record we can merge multiple classes and make composite key of map easily
  Good use cases of records
  a. DTOs
  b. return multiple objects: merge in same record, easy to read
  c. have composite key in map, merge classes in one with absolutely no code written,
      hashcode equals tostring , getter all provided by compiler  

b. Stream Api enahancement : mapMulti , comparison with flatmap
  
   flatMap and mapMulti both works for one to many options but have different use case
   a. in case of flatMap for each element a stream will be created containing all the items based on map transformation
      but in case of mapMulti a single stream is created and mutated for each iteration
   b. flatMap takes all the element from one to many but mapMulti have flexibility of 0 to all elements
    eg use case: we have employees list and we have hobbies list for each employee
	then using flatMap we will create n streams where n = number of employees
	meaning all the hobbies will be added
	in case of multiMap: we create single stream and is mutated by each iteration of employee
	meaning we have the flexiblity of using one or all hobbies
	eg: find all the hobbies starting with letter a 
	this can not be done using flatmap as filter will be based on employee and not hobbies
    so remember to use flatMap when we need all the hobbies
	but use multiMap when we need 0 - all hobbies based on logic
	
	toList method in stream api: This is same like Collectors.toList()
	but adds readability also one feature it adds
	the final List from toList method of stream is unmodifiable meaning we can not add,update,remove etc
	but add,update,remove etc can be done for Collectors.toList()
   

d. sealed types and records
e. strongly encapsulated jdk internals : to enhance security of jdk
f. new packaking api to package java application
g. warning for value based classes: laid foundation for future changed in jdk   

om shree ganeshaya namah
om shree sita rama lakshman hanuman

c. pattern matching for instanceof
  It was a preview feature since jdk 14 now in jdk 16 it is a permanent feature
  
Note: We can use Record and sealed interface/classes together
   A Record is a final class hence no once can extend it
   but it can extend sealed interface's permit types 
   hence field constructor, getters and hashcode equals tostring will be provided by jdk compiler   
   summary: 
   a. Record class is final so no one can extend it
   b. Record class can not extend but implement as it already extend java.lang.Record class
   c. Since Record class is final it can be children of sealed class
      remember child of sealed class/interface is either final or non-sealed



===============Tips on jdk migration===================
a. update the maven plugin to support new jdk version like 17 : build tools and plugins
   in this step do following
   a. update the java version to 17
   b. update the maven plugin and other plugin versions as per jdk 17
     or update the gradle version and other plugins version as per jdk 17 support
   c. use correct IDE that supports jdk 17 version as sts few version spport till jdk 15 only
b. spring/springboot compatiblity version based on new jdk version :
   -> some jdk version require minimum spring boot version to work with
   demo will be done for a sample spring boot app to upgrade to jdk 17   
c. check dependency compaiblity like hibernate version that is compatible with latest jdk version like 17
   update the versions of dependencies that support new version of jdk 17
d. fix migration issues like issue with jaxb : used in demo  
   inspring boot we might have to create @Bean and @Configuration in new way of jdk 17 
   
om shree ganeshaya namah
om shree sita rama lakshman hanuman

- Different developers working for tools,frameworks, apps, webb apps are using jdk internal libraries
  like sun.* package which was meant to be used by jdk internally
  this result in low encapsulation have security issues and also reduces maintainablity
  jdk implementors were restricted to modify these package in fear it might break for these external developers
  internally they can modify but for external direct dev it was making it a headache and reduces maintainablity

- Even the private methods/constructors/fields were forecfully used using reflection
  to tackles these modules were introduced in jdk9
  however using a flag --illegal-access it can be allowed freely
  using these flags even internal libraries can be used again causing the risk
  this was done for migration only
  in jdk 16 few apis like keystore is made more encapsulated
  it is declared with opens and fixed package which is internal to jdk
  also exports is done to specific internal packages
  hence import can be done in fixed modules, and only fixed module can use reflection to use these internal libraries
  we as a dev can not now either import or even use reflection to code due to these jpms restrictions

  however before jdk 16 it was still possible to use them using flag --illegal-access
  now in jdk 16 this flag can not be updated at all and is deny always

- Using tool like jdeps and maven we can identify all th depending modules/packages
  even shows what all internal libraries are used
  so before migrating we must use public apis  
  Good approach will be to use jdeps and identify what all internal libraries are used
  migrate them before migrating to jdk 17 as now the flag --illegal-access is removed
  and for new apis always use public facing apis only which are actually open or export correctly using jpms module-info.class
  
- JDK 16 introduced jpackage
  it is a packaging tool where we can provide jars and then it creates native executable files
  somewhat similar to how graalvm create exe/bin os specific native file to be executed
  this way even java need not to be installed within the machine
  this is self contained package  
  
=============== JDK 17 Features================
Long term support
released on september 2021

a. Sealed Class/interface feature is made permanent with no extra feature added since its firt preview in jdk 15
b. Strongly encapsulated internal jdk library
   illegal-access vm argument is completely removed now, earlier(jdk 16) value of this was not changeable by argument
c. Removals and Deprecations
d. Pattern Matching to switch case
   we can use switch expression based on instance of type and not value
   lambda option is useed
   for more than one line yield is used
   default is mandatory
   Pattern matching is very good use case in functional programming languages
   as it enhances code readability and reduces verbosity and reduces line of code and is more concise
   it is still enhancing and evolving so more features will use pattern matching
   
   Remeber that the pattern matching works for switch expression and switch case both
   now in switch case even object can be compared
   earlier only byte,short,char,int,Wrapper Integer,Charachter,String and Enum was allowed

- Future of java
 a. Project Loom
 b. Project valhala
 c. Project panama : way of java using native code, easy access to java dev to use native library code easily. 