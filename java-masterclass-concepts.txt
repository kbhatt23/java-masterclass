- keywords are oob words/commands that have meaning in java/any other programming language
- They explain things to java compilers as to what should be done in code, combination of such keywords and identifiers become code
- amazon have created free version of java 8 and above called correto as java 8 and above are not free for commercial usage
- access modifer -> how external classes/code can access our class/method/resource(variables)
- class can have only public or default access modifier, can not be private or protected
- keywords and identifiers in java is case sensitive
- While running using the main method String... vararg or String[] both works , but apart from this no other combinations works:
	public static void main(String... args)   or public static void main(String[] args) 
- variable are defined with a name and data type, the vlaue will be kpt in RAM meory based on data type
	-> the variable can be used to use the value without thinkning how data i saved in memory

- String s= messi creates one object in string constant pool usable for other variables, 
- String s= new String("messi") creates one object in constant pool and another object that points to this constant pool

- Wrapper classes are object kind behaviour of prinitive data types -> mostly used in generics and collections
- Autmoatic boxing and unbxoing happens
- Down side are below:
	a. if we convert int ot INteger aumatic boxing happens , but it consumes memory
	b. It is ummutable so if we modify its value a enw object is created and assinged to variabl.
	c. we can do ++ --  operator but for that it unwraps the Integer object ot prmitive modidfy the primitive then box(creat enew object) to Integer object
- If we store more than max or lesser than min vlaue of int it gives compilation error, however we can force type cast that bust it and cause underflow
	-> no runtime or compilation error in that case but it just try to convert it using overflow or underflow
- JVM allows even _ in between and bypass these _ chars by using Java 7 and higher
- by defaut int/int gives double -> however we cna type cast to int whihc just ignore decimcal places and od not roundoff
	-> for round off using Mat.roundoff funtcion or use floor or cieling
- floor will give minimum non doulbe value and ceil will give maximum next whole value
	2.2 floor will give 2 and ceil will give 3 , round will give 2 , round for 2.6 will give 3
- char is 2 byte meaning 16 bit and hence int can hold it without typecasting, but convert the char to ascii value
- int is default literal for whole number and double is default literal value for decimal numbers
- so even if we define a variable to some data type -> the value literal is always pointing to default one 
- double is default fractional data type and hence in float declaration we need to add f at the end on literal
- double can store more bigger values(64 bit) and also during division it stores more characters after ., meaning more presecision
- arithematic operations is faster as hardware level supported chips are build like that
- In integer and double literal we can add _ in between and compiler ignores them as they are added for readability
- BigDecimal is more precise and have a lot of supporting methods then float and double both
- char can store only single charachter and that can be number, special characther, alphabets anything and also it;s ascii value is different for case insenstivite chars
- char is 16 bit and can be easily hold up by int variable but it converts it char to its ascii value
- boolean size in bit is 1 bit as it can have 0 or 1 in memory -> true or false
- max size/width of a string is the max value of integer, String is 2 byte storage in java just like char
- + operator if used with one of the string then it always do concatenation at all level until () are used to do opeartions for other data type
- Teranry operator can replace if else condition but it always return a vlaue in both true and flase case and hence shall always be assigned to a variable for a result value
- + and - have same precendencce because even though we execute any operation result will be same same with division and multiplication

- Keywords are predifined words that have some meaning in a programming language , any of the keywords can not be an identifier . eg int int=23 will give error as int variable name is not possible
- any line in java wihtout data typeis expression , eg int la =23 -> la=23 is expression , if(kal == 22) kal ==23 is expression and so 
- Every line injava is a statment -> or a logical line as a lot of time we put enter and ame line ends in next line
	-> basically any code that starts and end till ; comes it is a single statment
- A white sapce is diferene bwtween keywors/identifiers  -> one or more space will mean asingle space by java compiler
- methods are created ro reduce duplication of code and make more reusable -> future cchanges will be done at one place
- overloading means createing a new method with same name but different method arguments/parameter - > all kind fo freedom for any method is given to this unlike overriding
- While creating we must ensure that there should not be amehtod in same class with same name and same argument paramters
		-> meaning just changing return type wont help in compiling if we have 2 methods with same name and same arguments

- method overloading is very useful for code readability and reusabiliy
	> we can remmeber one method name easily and based on different input arguments we can achive same functionality with idfferent inputs
-> eg of overloading is system.out.println -? same method name but input can be string, double, int etc -? easier to remmeber

-> switch case can be done only on ints, enums, strings -> can notbe used for objects -> overl all -> byte ,short ,char and int are part of ints(positive numbers)
	Stirng swithc is added in java 7 only earlier it was int and its small types and enum only 

-> in for loop if we do a break the increment stamtent will not get called, however if contiue is used the increment statetment will get called
-< in for loop on contine increment operator gets called automatically so that index goes to next, In while loop on contiue index do not get incremented we need to do it manually
	-> in while loop if we do not do amnual increment it will go to infinite loop

- > Integer.parseInt is better when we just need integer as it returns primitive type and Valueof method returns Integer object
	-> we cna save autounboxing


===========OOPS===================

Objects : A rela life entity, in java code from one aprt interact to other using object calls,	
	-> any real life thing also have a state and behvaiour same happens in java classes -> state -> instance vriables and methods act as behviour of object
- Class : Class is nothing but a template that helps us how the objects will be , any object form this class will take the things(behavious and state) using class template
- any local variable have to be initalized first before usage : int i; i+2; will give compilation erro  do like i=0; i+=2;
- instance variable gets defaul values as they are in object heap and not in stack(local variables)

Rules for constructors:
- if no constructor is added by dev a no arg onstructor with first line as super no arg cosntrucotr call is added by compliler
- if any constructor is added by dev compiler do not add default no arg constuctor
- if in our constructor fisr line is automatic super no arg constructor
	-> super or this constructor call shud be first line only in constructor
- if super class has no default constructor then while extending in child it causes compialtion error as it looks for no arg constructor
	-> either add no arg constructor in super or in child creat cusotmconstrucotr to call cusotm construcotr using super 
- everytime in any constructor call goes first to super -> super till object then it comes back to the stack
- any default value wadded in instance variable if overidden inconstructor will overrirde it

- in constructor it is advised not to call another set method or another method , instead if we want to set more than one better call another constructor using this
- this and super keywords can not be used in staic methods
- super. can be used to call methods super(...) can be used for ocnstructor call to ssuper class this(...) local class constructor 
- even abstract classes who we cna not instantiate at all still have constructors but interface do not have constructor
- all classes whihc are part of object heirachy have constructors
- we can not override static and final methods

Steps in identifying static / instance blocks and constructor flow:
- only once first the super class staitc blocks form top to down gets called then childs static blocks gets called form top to botton
- then the instance blocks of super class gets called from top to bottom
- then the super class cosntructor gets classed
- child instance bloks gets called from top to bottom
-child constructor gets called
->----------------- Meaning that the abosliute last place whihc overrides all the values of instance variable is at the constructor leve
	least preference is instance variable leve -> instance block leve -> construcotr level